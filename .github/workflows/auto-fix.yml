name: Auto Fix CI Failures

on:
  workflow_run:
    workflows: ["Basic CI"]        # TODO: Update this to match your CI workflow name exactly
    types: [completed]
  workflow_dispatch:
    inputs:
      pr_branch:
        description: "PR head branch (for manual testing; same-repo only)"
        required: false
      base_branch:
        description: "Base branch (default: main)"
        required: false
        default: "main"
      force_run:
        description: "Force run even if no failures detected"
        type: boolean
        required: false
        default: false

permissions:
  contents: write
  pull-requests: write
  actions: read
  id-token: write

env:
  MAX_RETRY_ATTEMPTS: 3
  CLEANUP_THRESHOLD: 10  # Keep only last 10 fix branches

jobs:
  auto-fix:
    # Only for failed PR runs OR manual runs (but not if this is a retry from same PR)
    if: |
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'failure' &&
       github.event.workflow_run.event == 'pull_request' &&
       !startsWith(github.event.workflow_run.head_branch, 'claude-auto-fix-ci-') &&
       !contains(github.event.workflow_run.head_commit.message, 'chore(ci): auto-fix CI failures')) ||
      (github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Print triggering context (debug)
        run: |
          echo "::group::Trigger Context"
          echo "event_name=${{ github.event_name }}"
          echo "repository=${{ github.repository }}"
          echo "run_id=${{ github.run_id }}"
          echo "run_number=${{ github.run_number }}"
          
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "workflow_run.name=${{ github.event.workflow_run.name }}"
            echo "workflow_run.conclusion=${{ github.event.workflow_run.conclusion }}"
            echo "workflow_run.event=${{ github.event.workflow_run.event }}"
            echo "workflow_run.head_branch=${{ github.event.workflow_run.head_branch }}"
            echo "workflow_run.id=${{ github.event.workflow_run.id }}"
          else
            echo "manual pr_branch=${{ inputs.pr_branch }}"
            echo "manual base_branch=${{ inputs.base_branch }}"
            echo "manual force_run=${{ inputs.force_run }}"
          fi
          echo "::endgroup::"

      - name: Verify Claude API key exists
        run: |
          if [ -z "${{ secrets.ANTHROPIC_API_KEY }}" ] && [ -z "${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}" ]; then
            echo "::error::Missing required API keys. Please set either ANTHROPIC_API_KEY or CLAUDE_CODE_OAUTH_TOKEN in repository secrets."
            echo "::error::Visit: https://github.com/${{ github.repository }}/settings/secrets/actions"
            exit 1
          fi
          echo "‚úÖ API key configuration verified"

      - name: Determine PR and branches
        id: pick
        uses: actions/github-script@v7
        with:
          script: |
            try {
              if (context.eventName === 'workflow_dispatch') {
                const prBranch = '${{ inputs.pr_branch }}';
                const baseBranch = '${{ inputs.base_branch }}' || 'main';
                
                if (!prBranch) {
                  core.setFailed('For manual run, pr_branch input is required.');
                  return;
                }
                
                core.setOutput('head_ref', prBranch);
                core.setOutput('base_ref', baseBranch);
                core.setOutput('number', '');
                core.setOutput('same_repo', 'true');
                core.setOutput('pr_url', '');
                core.info(`Manual run: ${prBranch} -> ${baseBranch}`);
                return;
              }

              // workflow_run path
              const run = context.payload.workflow_run;
              const prLite = run.pull_requests && run.pull_requests[0];
              
              if (!prLite) {
                core.setFailed('No PR associated with this workflow run. This might be a push to main branch.');
                return;
              }

              // Fetch full PR details
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner, 
                repo: context.repo.repo, 
                pull_number: prLite.number
              });
              
              const sameRepo = pr.head.repo.full_name === `${context.repo.owner}/${context.repo.repo}`;
              
              core.setOutput('head_ref', pr.head.ref);
              core.setOutput('base_ref', pr.base.ref);
              core.setOutput('number', pr.number.toString());
              core.setOutput('same_repo', sameRepo ? 'true' : 'false');
              core.setOutput('pr_url', pr.html_url);
              
              core.info(`PR #${pr.number}: ${pr.head.ref} -> ${pr.base.ref} (same_repo: ${sameRepo})`);
              
            } catch (error) {
              core.setFailed(`Failed to determine PR details: ${error.message}`);
            }

      - name: Checkout target branch
        uses: actions/checkout@v5
        with:
          ref: ${{ steps.pick.outputs.head_ref }}
          fetch-depth: 0
          persist-credentials: true
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Setup git identity
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name  "github-actions[bot]"
          git config --global init.defaultBranch main

      - name: Cleanup old fix branches
        if: steps.pick.outputs.same_repo == 'false'
        continue-on-error: true
        run: |
          echo "::group::Cleaning up old fix branches"
          
          # Get all claude-auto-fix branches, sorted by creation date (oldest first)
          OLD_BRANCHES=$(git branch -r --sort=creatordate | grep "origin/claude-auto-fix-ci-" | head -n -${{ env.CLEANUP_THRESHOLD }} || true)
          
          if [ -n "$OLD_BRANCHES" ]; then
            echo "Found old branches to cleanup:"
            echo "$OLD_BRANCHES"
            
            echo "$OLD_BRANCHES" | while read -r branch; do
              # Remove origin/ prefix and delete branch
              BRANCH_NAME=${branch#origin/}
              echo "Deleting branch: $BRANCH_NAME"
              git push origin --delete "$BRANCH_NAME" || echo "Failed to delete $BRANCH_NAME"
            done
          else
            echo "No old branches to cleanup"
          fi
          
          echo "::endgroup::"

      - name: Decide fix branch strategy
        id: branch
        run: |
          if [ "${{ steps.pick.outputs.same_repo }}" = "true" ]; then
            echo "branch=${{ steps.pick.outputs.head_ref }}" >> $GITHUB_OUTPUT
            echo "mode=direct" >> $GITHUB_OUTPUT
            echo "üîß Will push fixes directly to: ${{ steps.pick.outputs.head_ref }}"
          else
            # Create unique branch name with timestamp to avoid collisions
            TIMESTAMP=$(date +%s)
            FIX_BRANCH="claude-auto-fix-ci-${{ steps.pick.outputs.head_ref }}-${{ github.run_id }}-${TIMESTAMP}"
            
            echo "Creating fix branch: $FIX_BRANCH"
            git checkout -b "$FIX_BRANCH"
            
            echo "branch=$FIX_BRANCH" >> $GITHUB_OUTPUT
            echo "mode=branch" >> $GITHUB_OUTPUT
            echo "üîß Created fix branch: $FIX_BRANCH"
          fi

      - name: Collect failed job details
        if: github.event_name == 'workflow_run'
        id: details
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const run_id = context.payload.workflow_run.id;
              
              // Get all jobs for the failed workflow run
              const { data } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner, 
                repo: context.repo.repo, 
                run_id
              });
              
              const failed = data.jobs.filter(j => j.conclusion === 'failure');
              const failedNames = failed.map(j => j.name);
              const failedDetails = failed.map(j => ({
                name: j.name,
                steps: j.steps?.filter(s => s.conclusion === 'failure').map(s => ({
                  name: s.name,
                  conclusion: s.conclusion
                })) || []
              }));
              
              core.setOutput('failed', JSON.stringify(failedNames));
              core.setOutput('failed_details', JSON.stringify(failedDetails));
              
              core.info(`Found ${failedNames.length} failed jobs: ${failedNames.join(', ')}`);
              
            } catch (error) {
              core.setFailed(`Failed to collect job details: ${error.message}`);
            }

      - name: Create backup before Claude changes
        run: |
          echo "::group::Creating backup"
          git stash push -m "backup-before-claude-$(date +%s)" --include-untracked || echo "Nothing to backup"
          echo "::endgroup::"

      - name: Claude - Attempt targeted CI fixes
        id: claude
        continue-on-error: true
        uses: anthropics/claude-code-action@v1
        with:
          prompt: |
            ## /fix-ci

            **Repository:** ${{ github.repository }}
            **Base Branch:** ${{ steps.pick.outputs.base_ref }}
            **PR Branch:** ${{ steps.pick.outputs.head_ref }}
            **Failed Jobs:** ${{ steps.details.outputs.failed || 'Manual run - check all potential issues' }}
            
            **Context:** This is an automated CI fix request. A workflow run failed and I need to make minimal, targeted changes to resolve the failing checks.

            **CRITICAL: You MUST fix the actual errors, not just format code. Focus on language-specific issues:**

            ## üêç **Python Fixes**
            - **Syntax errors**: Missing colons `:`, parentheses, brackets, indentation
            - **Import errors**: Missing imports, circular imports, wrong module names
            - **Linting**: flake8, pylint, black formatting issues
            - **Tests**: pytest failures, assertion errors, missing test dependencies
            - **Commands to run**: `python -m py_compile *.py`, `flake8 .`, `pytest`, `black --check .`

            ## üèóÔ∏è **Terraform/HCL Fixes**
            - **Syntax errors**: Missing braces `{}`, quotes, commas
            - **Resource errors**: Invalid resource names, missing required arguments
            - **Variable errors**: Undefined variables, type mismatches
            - **Provider issues**: Missing provider blocks, version constraints
            - **Commands to run**: `terraform fmt -check`, `terraform validate`, `terragrunt validate`

            ## üìú **Bash/Shell Script Fixes**
            - **Syntax errors**: Missing quotes, unescaped characters, wrong operators
            - **Variable errors**: Undefined variables, wrong variable expansion
            - **Permissions**: Executable permissions (`chmod +x`)
            - **Shellcheck issues**: SC codes, best practices violations
            - **Commands to run**: `shellcheck *.sh`, `bash -n script.sh`

            ## üü® **JavaScript/TypeScript Fixes**
            - **Syntax errors**: Missing semicolons, brackets, parentheses
            - **ESLint issues**: Unused variables, formatting, best practices
            - **TypeScript errors**: Type annotations, interface issues
            - **Import/Export**: Missing imports, wrong paths, circular dependencies
            - **Tests**: Jest/Mocha failures, missing mocks
            - **Commands to run**: `npm run lint`, `npm run type-check`, `npm test`, `npm run build`

            ## üìÑ **YAML Fixes**
            - **Indentation errors**: Wrong spacing, tabs vs spaces
            - **Syntax errors**: Missing colons, wrong list formatting
            - **GitHub Actions**: Workflow syntax, invalid action versions
            - **Docker Compose**: Service definitions, volume syntax
            - **Commands to run**: `yamllint .`, check specific YAML parsers

            ## üîß **General CI/CD Issues**
            - **Dockerfile**: Invalid instructions, missing dependencies
            - **Package files**: package.json, requirements.txt, Cargo.toml issues
            - **Configuration files**: Wrong paths, missing environment variables
            - **Dependencies**: Version conflicts, missing packages

            **Your Task - Follow This Process:**

            1. **EXAMINE CI LOGS**: Look at the actual error messages and failing commands
            
            2. **IDENTIFY FILE TYPES**: Determine which languages/tools are failing:
               ```bash
               find . -name "*.py" -o -name "*.tf" -o -name "*.sh" -o -name "*.js" -o -name "*.ts" -o -name "*.yml" -o -name "*.yaml"
               ```
            
            3. **RUN LANGUAGE-SPECIFIC CHECKS**:
               - Python: `python -m py_compile file.py && flake8 file.py`
               - Terraform: `terraform fmt -check . && terraform validate`
               - Shell: `shellcheck script.sh && bash -n script.sh`  
               - JavaScript: `npm run lint && npm run build`
               - YAML: `yamllint file.yml`
            
            4. **FIX EACH ERROR SYSTEMATICALLY**:
               - **Syntax first**: Fix all parsing/compilation errors
               - **Linting second**: Address style and quality issues
               - **Tests last**: Fix failing test cases
            
            5. **VERIFY EACH FIX**: Re-run the specific command to ensure it passes
            
            6. **COMMON FIXES BY LANGUAGE**:

            **Python Examples:**
            ```python
            # Fix: def greet(name) # Missing colon
            def greet(name):  # ‚úÖ Added colon
                return f"Hello, {name}"
            
            # Fix: Missing imports
            import os  # ‚úÖ Add missing imports
            
            # Fix: Add newline at end of file ‚úÖ
            ```

            **Terraform Examples:**
            ```hcl
            # Fix: Missing quotes
            resource "aws_instance" "example" {  # ‚úÖ Added quotes
              ami           = "ami-12345"        # ‚úÖ Added quotes
              instance_type = "t2.micro"
            }
            ```

            **Shell Examples:**
            ```bash
            #!/bin/bash
            # Fix: Unquoted variables
            echo "Hello, ${name}"  # ‚úÖ Quoted variable
            
            # Fix: Add error handling
            set -euo pipefail  # ‚úÖ Add strict mode
            ```

            **JavaScript Examples:**
            ```javascript
            // Fix: Missing semicolon
            const name = 'World';  // ‚úÖ Added semicolon
            
            // Fix: Unused variables
            // const unused = 'test';  // ‚úÖ Remove or use variable
            ```

            **YAML Examples:**
            ```yaml
            # Fix: Indentation
            jobs:
              test:  # ‚úÖ Proper 2-space indentation
                runs-on: ubuntu-latest
            ```

            **Constraints:**
            - DO NOT modify files in .github/workflows/ directory
            - Fix ALL syntax errors completely - don't leave broken code
            - Add missing newlines at end of files if required by linters
            - Keep changes minimal but ensure they actually work
            - Test each fix immediately after making it

            **VERIFICATION REQUIREMENTS:**
            After fixing each file type, you MUST run verification commands:
            - Python: `find . -name "*.py" -exec python -m py_compile {} \;`
            - Terraform: `terraform validate` (if .tf files exist)
            - Shell: `find . -name "*.sh" -exec shellcheck {} \;`
            - JavaScript/Node: `npm run lint` or `npm run build` (if package.json exists)
            - YAML: Check syntax with appropriate tools

            **Final Step:** Provide a detailed summary of:
            - Which files were modified
            - What specific errors were fixed for each language
            - Which verification commands passed
            - Any remaining issues that need manual intervention

            Start by examining the repository structure and CI logs to understand what languages and tools are being used.
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY || secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          claude_args: "--max-turns 20 --model claude-sonnet-4-20250514"

      - name: Verify fixes actually work
        id: verify_fixes
        if: steps.claude.outcome == 'success'
        continue-on-error: true
        run: |
          echo "::group::Verifying that fixes actually resolve CI issues"
          
          # Check if any files were modified
          CHANGED_FILES=$(git diff --name-only HEAD || true)
          STAGED_FILES=$(git diff --staged --name-only || true)
          UNTRACKED_FILES=$(git ls-files --others --exclude-standard || true)
          
          echo "Modified files:"
          echo "${CHANGED_FILES:-None}"
          echo ""
          echo "Staged files:"
          echo "${STAGED_FILES:-None}"
          echo ""
          echo "Untracked files:"
          echo "${UNTRACKED_FILES:-None}"
          
          # Show a summary of changes
          if [ -n "$CHANGED_FILES" ] || [ -n "$STAGED_FILES" ] || [ -n "$UNTRACKED_FILES" ]; then
            echo ""
            echo "Summary of changes:"
            git status --porcelain=v1
            echo ""
            echo "Detailed diff:"
            git diff HEAD
            
            echo ""
            echo "üß™ Running language-specific verification tests..."
            
            # Python verification
            if find . -name "*.py" -not -path "./.git/*" | head -1 | grep -q "\.py$"; then
              echo "üêç Checking Python files..."
              if command -v python3 &> /dev/null; then
                echo "  - Syntax check:"
                find . -name "*.py" -not -path "./.git/*" -exec python3 -m py_compile {} \; && echo "    ‚úÖ Python syntax check passed" || echo "    ‚ùå Python syntax errors still exist"
                
                if command -v flake8 &> /dev/null; then
                  echo "  - Flake8 linting:"
                  flake8 . --exclude=.git && echo "    ‚úÖ Flake8 passed" || echo "    ‚ö†Ô∏è Flake8 issues remain"
                fi
                
                if command -v black &> /dev/null; then
                  echo "  - Black formatting:"
                  black --check . && echo "    ‚úÖ Black formatting passed" || echo "    ‚ö†Ô∏è Black formatting issues remain"
                fi
              fi
            fi
            
            # Terraform verification
            if find . -name "*.tf" -not -path "./.git/*" | head -1 | grep -q "\.tf$"; then
              echo "üèóÔ∏è Checking Terraform files..."
              if command -v terraform &> /dev/null; then
                echo "  - Terraform formatting:"
                terraform fmt -check=true -recursive && echo "    ‚úÖ Terraform formatting passed" || echo "    ‚ö†Ô∏è Terraform formatting issues remain"
                
                echo "  - Terraform validation:"
                terraform init -backend=false &>/dev/null || true
                terraform validate && echo "    ‚úÖ Terraform validation passed" || echo "    ‚ö†Ô∏è Terraform validation issues remain"
              fi
            fi
            
            # Shell script verification
            if find . -name "*.sh" -not -path "./.git/*" | head -1 | grep -q "\.sh$"; then
              echo "üìú Checking Shell scripts..."
              if command -v shellcheck &> /dev/null; then
                echo "  - Shellcheck:"
                find . -name "*.sh" -not -path "./.git/*" -exec shellcheck {} \; && echo "    ‚úÖ Shellcheck passed" || echo "    ‚ö†Ô∏è Shellcheck issues remain"
              fi
              
              echo "  - Bash syntax:"
              find . -name "*.sh" -not -path "./.git/*" -exec bash -n {} \; && echo "    ‚úÖ Bash syntax check passed" || echo "    ‚ùå Bash syntax errors still exist"
            fi
            
            # JavaScript/TypeScript verification
            if [ -f "package.json" ]; then
              echo "üü® Checking JavaScript/TypeScript project..."
              if command -v npm &> /dev/null; then
                echo "  - Dependencies:"
                npm ci --silent &>/dev/null || npm install --silent &>/dev/null && echo "    ‚úÖ Dependencies installed" || echo "    ‚ö†Ô∏è Dependency issues"
                
                if npm run --silent lint 2>/dev/null; then
                  echo "    ‚úÖ npm lint passed"
                else
                  echo "    ‚ö†Ô∏è npm lint issues may remain or script not available"
                fi
                
                if npm run --silent type-check 2>/dev/null; then
                  echo "    ‚úÖ TypeScript type checking passed"
                elif npm run --silent build 2>/dev/null; then
                  echo "    ‚úÖ Build passed"
                else
                  echo "    ‚ö†Ô∏è Build/type-check issues may remain"
                fi
              fi
            fi
            
            # YAML verification
            if find . -name "*.yml" -o -name "*.yaml" | grep -v ".git" | head -1 | grep -q "\.ya\?ml$"; then
              echo "üìÑ Checking YAML files..."
              if command -v yamllint &> /dev/null; then
                echo "  - YAML linting:"
                yamllint . && echo "    ‚úÖ YAML linting passed" || echo "    ‚ö†Ô∏è YAML linting issues remain"
              fi
              
              # Basic YAML syntax check with Python
              if command -v python3 &> /dev/null; then
                echo "  - YAML syntax:"
                python3 -c "
import yaml
import glob
import sys
errors = 0
for file in glob.glob('**/*.yml', recursive=True) + glob.glob('**/*.yaml', recursive=True):
    if '.git' in file: continue
    try:
        with open(file) as f:
            yaml.safe_load(f)
    except Exception as e:
        print(f'    ‚ùå {file}: {e}')
        errors += 1
if errors == 0:
    print('    ‚úÖ YAML syntax check passed')
sys.exit(errors > 0)
" || echo "    ‚ö†Ô∏è YAML syntax issues remain"
              fi
            fi
            
            echo "verification_status=success" >> $GITHUB_OUTPUT
          else
            echo "No changes detected"
            echo "verification_status=no_changes" >> $GITHUB_OUTPUT
          fi
          
          echo "::endgroup::"

      - name: Handle Claude failure
        if: steps.claude.outcome == 'failure'
        run: |
          echo "::warning::Claude failed to make fixes. This could be due to:"
          echo "- Complex issues requiring human intervention"
          echo "- API rate limits or connectivity issues"  
          echo "- Repository structure that Claude couldn't understand"
          echo ""
          echo "Manual investigation may be required."
          
          # Restore backup if it exists
          git stash pop || echo "No backup to restore"

      - name: Commit and push changes
        if: steps.claude.outcome == 'success'
        run: |
          echo "::group::Committing changes"
          
          # Stage all changes
          git add -A
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "::notice::No changes to commit - Claude may have determined no fixes were needed"
            exit 0
          fi
          
          # Create detailed commit message
          COMMIT_MSG="chore(ci): auto-fix CI failures

          Auto-generated fixes for failing CI jobs:
          ${{ steps.details.outputs.failed || 'Manual run' }}
          
          Generated by: ${{ github.workflow }} #${{ github.run_number }}
          Triggered by: ${{ github.event_name }}
          Repository: ${{ github.repository }}"
          
          git commit -m "$COMMIT_MSG"
          
          # Push with retry logic
          for i in $(seq 1 ${{ env.MAX_RETRY_ATTEMPTS }}); do
            if git push -u origin "${{ steps.branch.outputs.branch }}"; then
              echo "‚úÖ Successfully pushed changes (attempt $i)"
              break
            else
              echo "‚ö†Ô∏è  Push failed (attempt $i/${{ env.MAX_RETRY_ATTEMPTS }})"
              if [ $i -lt ${{ env.MAX_RETRY_ATTEMPTS }} ]; then
                echo "Retrying in 5 seconds..."
                sleep 5
                git pull --rebase origin "${{ steps.branch.outputs.branch }}" || true
              else
                echo "::error::Failed to push after ${{ env.MAX_RETRY_ATTEMPTS }} attempts"
                exit 1
              fi
            fi
          done
          
          echo "::endgroup::"

      - name: Comment on original PR (direct push)
        if: |
          github.event_name == 'workflow_run' && 
          steps.branch.outputs.mode == 'direct' && 
          steps.pick.outputs.number != '' &&
          steps.claude.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            let commentBody = `ü§ñ **Auto-fixes applied**

            I've automatically pushed fixes for the failing CI jobs directly to \`${{ steps.pick.outputs.head_ref }}\`.

            **Failed jobs:** ${{ steps.details.outputs.failed }}

            ## üîß Fixes Applied

            `;

            // Get the changes and create a detailed comment
            const { execSync } = require('child_process');
            
            try {
              // Get changed files
              const changedFiles = execSync('git diff --name-only HEAD~1 HEAD', { encoding: 'utf8' }).trim().split('\n').filter(f => f);
              
              if (changedFiles.length > 0) {
                commentBody += `**Modified files:**\n`;
                changedFiles.forEach(file => {
                  const ext = file.split('.').pop().toLowerCase();
                  const emoji = {
                    'py': 'üêç',
                    'tf': 'üèóÔ∏è',
                    'hcl': 'üèóÔ∏è',
                    'sh': 'üìú',
                    'bash': 'üìú',
                    'js': 'üü®',
                    'ts': 'üî∑',
                    'yml': 'üìÑ',
                    'yaml': 'üìÑ',
                    'json': 'üì¶',
                    'md': 'üìù'
                  };
                  commentBody += `- ${emoji[ext] || 'üìÑ'} \`${file}\`\n`;
                });
                commentBody += '\n';

                // Analyze the diff for language-specific fixes
                const diff = execSync('git diff HEAD~1 HEAD', { encoding: 'utf8' });
                const fixes = [];
                
                // Python fixes
                if (diff.includes('.py') || diff.match(/def.*:\s*\n/)) {
                  if (diff.includes('def ') && diff.includes('):')) {
                    fixes.push('üêç **Python**: Fixed missing colons in function definitions');
                  }
                  if (diff.match(/\+.*import\s+/)) {
                    fixes.push('üêç **Python**: Fixed missing imports');
                  }
                  if (diff.includes('assert') && diff.includes('==')) {
                    fixes.push('üêç **Python**: Fixed test assertions');
                  }
                  if (diff.match(/\+.*\n$/m)) {
                    fixes.push('üêç **Python**: Added missing newlines for PEP8 compliance');
                  }
                }
                
                // Terraform/HCL fixes
                if (diff.includes('.tf') || diff.includes('.hcl')) {
                  if (diff.includes('resource ') && diff.includes('{')) {
                    fixes.push('üèóÔ∏è **Terraform**: Fixed resource block syntax');
                  }
                  if (diff.match(/\+.*=.*"/)) {
                    fixes.push('üèóÔ∏è **Terraform**: Fixed variable assignments and quotes');
                  }
                }
                
                // Shell script fixes
                if (diff.includes('.sh') || diff.includes('#!/bin/bash')) {
                  if (diff.includes('${') && diff.includes('}')) {
                    fixes.push('üìú **Shell**: Fixed variable expansions and quoting');
                  }
                  if (diff.includes('set -') || diff.includes('pipefail')) {
                    fixes.push('üìú **Shell**: Added error handling and strict mode');
                  }
                }
                
                // JavaScript/TypeScript fixes
                if (diff.includes('.js') || diff.includes('.ts')) {
                  if (diff.includes(';')) {
                    fixes.push('üü® **JavaScript**: Fixed missing semicolons');
                  }
                  if (diff.match(/^-.*\/\/.*unused/m)) {
                    fixes.push('üü® **JavaScript**: Removed unused variables and imports');
                  }
                  if (diff.includes('export ') || diff.includes('import ')) {
                    fixes.push('üü® **JavaScript**: Fixed import/export statements');
                  }
                }
                
                // YAML fixes  
                if (diff.includes('.yml') || diff.includes('.yaml')) {
                  if (diff.match(/^\+\s{2,}/m)) {
                    fixes.push('üìÑ **YAML**: Fixed indentation and formatting');
                  }
                  if (diff.includes('runs-on:') || diff.includes('uses:')) {
                    fixes.push('üìÑ **YAML**: Fixed GitHub Actions workflow syntax');
                  }
                }
                
                // General fixes
                if (diff.match(/^-.*#.*\n\+.*$/m)) {
                  fixes.push('üîß **General**: Fixed linting and formatting issues');
                }
                
                if (diff.includes('package.json') || diff.includes('requirements.txt')) {
                  fixes.push('üì¶ **Dependencies**: Fixed package configuration');
                }
                
                if (fixes.length > 0) {
                  commentBody += '**Language-specific fixes applied:**\n';
                  fixes.forEach(fix => {
                    commentBody += `${fix}\n`;
                  });
                } else {
                  commentBody += '‚úÖ Applied various code quality and syntax improvements\n';
                }
                
                commentBody += '\n';
                
                // Show diff stats
                const diffStat = execSync('git diff --stat HEAD~1 HEAD', { encoding: 'utf8' });
                if (diffStat) {
                  commentBody += `**Changes summary:**\n\`\`\`\n${diffStat}\n\`\`\`\n\n`;
                }
                
              } else {
                commentBody += '‚ö†Ô∏è No changes were made - Claude may have determined the issues require manual intervention.\n\n';
              }
            } catch (error) {
              commentBody += '‚ö†Ô∏è Unable to analyze changes in detail, but fixes were attempted.\n\n';
              console.error('Error analyzing diff:', error);
            }

            commentBody += `## üîÑ Next Steps

            The CI will re-run automatically to verify these fixes. If issues persist:
            - The fixes may be incomplete and require manual intervention
            - There might be additional errors not covered by the automated fixes
            - Consider reviewing the failing tests and error messages manually

            <details>
            <summary>Workflow Details</summary>
            
            - **Workflow:** ${{ github.workflow }}
            - **Run:** #${{ github.run_number }}
            - **Commit:** \`${context.sha.substring(0, 7)}\`
            - **Trigger:** Auto-fix for failed CI jobs
            </details>`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number('${{ steps.pick.outputs.number }}'),
              body: commentBody
            });

      - name: Create PR for fixes (fork case)
        if: steps.branch.outputs.mode == 'branch' && steps.claude.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const head = "${{ steps.branch.outputs.branch }}";
            const base = "${{ steps.pick.outputs.base_ref }}";
            
            // Check if PR already exists
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner, 
              repo: context.repo.repo, 
              state: 'open',
              head: `${context.repo.owner}:${head}`
            });
            
            if (prs.length > 0) {
              core.info(`PR already exists: ${prs[0].html_url}`);
              return;
            }
            
            // Create new PR
            const prBody = `ü§ñ **Automated CI Fixes**

            This PR contains automated fixes for failing CI jobs in the original PR.

            **Target PR:** ${{ steps.pick.outputs.pr_url }}
            **Failed Jobs:** ${{ steps.details.outputs.failed }}

            ## What was fixed
            Claude analyzed the failing CI jobs and applied targeted fixes to resolve the issues.

            ## Next Steps
            1. Review the changes in this PR
            2. If approved, merge this PR
            3. The fixes will be available for the original PR

            ---
            *Generated by ${{ github.workflow }} #${{ github.run_number }}*`;
            
            try {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner, 
                repo: context.repo.repo,
                title: `chore(ci): auto-fix CI failures for ${{ steps.pick.outputs.head_ref }}`,
                head: head,
                base: base,
                body: prBody
              });
              
              core.info(`‚úÖ Created fix PR: ${pr.html_url}`);
              
              // Add labels if they exist
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: ['automated', 'ci-fix', 'claude-generated']
                });
              } catch (labelError) {
                core.info('Could not add labels (labels may not exist)');
              }
              
            } catch (error) {
              core.setFailed(`Failed to create PR: ${error.message}`);
            }

      - name: Summary
        if: always()
        run: |
          echo "::group::Workflow Summary"
          echo "Event: ${{ github.event_name }}"
          echo "Branch Strategy: ${{ steps.branch.outputs.mode }}"
          echo "Target Branch: ${{ steps.branch.outputs.branch }}"
          echo "Claude Status: ${{ steps.claude.outcome }}"
          echo "PR Number: ${{ steps.pick.outputs.number }}"
          echo "::endgroup::"
          
          if [ "${{ steps.claude.outcome }}" = "success" ]; then
            echo "‚úÖ Workflow completed successfully"
          elif [ "${{ steps.claude.outcome }}" = "failure" ]; then
            echo "‚ö†Ô∏è  Claude fixes failed - manual intervention may be required"
          else
            echo "‚ÑπÔ∏è  Workflow completed with mixed results"
          fi