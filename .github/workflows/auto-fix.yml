name: Auto Fix CI Failures

on:
  workflow_run:
    workflows: ["Basic CI"]        # TODO: Update this to match your CI workflow name exactly
    types: [completed]
  workflow_dispatch:
    inputs:
      pr_branch:
        description: "PR head branch (for manual testing; same-repo only)"
        required: false
      base_branch:
        description: "Base branch (default: main)"
        required: false
        default: "main"
      force_run:
        description: "Force run even if no failures detected"
        type: boolean
        required: false
        default: false

permissions:
  contents: write
  pull-requests: write
  actions: read
  id-token: write

env:
  MAX_RETRY_ATTEMPTS: 3
  CLEANUP_THRESHOLD: 10  # Keep only last 10 fix branches

jobs:
  auto-fix:
    # Only for failed runs OR manual runs
    if: |
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'failure' &&
       !startsWith(github.event.workflow_run.head_branch, 'claude-auto-fix-ci-')) ||
      (github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Print triggering context (debug)
        run: |
          echo "::group::Trigger Context"
          echo "event_name=${{ github.event_name }}"
          echo "repository=${{ github.repository }}"
          echo "run_id=${{ github.run_id }}"
          echo "run_number=${{ github.run_number }}"
          
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "workflow_run.name=${{ github.event.workflow_run.name }}"
            echo "workflow_run.conclusion=${{ github.event.workflow_run.conclusion }}"
            echo "workflow_run.event=${{ github.event.workflow_run.event }}"
            echo "workflow_run.head_branch=${{ github.event.workflow_run.head_branch }}"
            echo "workflow_run.id=${{ github.event.workflow_run.id }}"
          else
            echo "manual pr_branch=${{ inputs.pr_branch }}"
            echo "manual base_branch=${{ inputs.base_branch }}"
            echo "manual force_run=${{ inputs.force_run }}"
          fi
          echo "::endgroup::"

      - name: Verify Claude API key exists
        run: |
          if [ -z "${{ secrets.ANTHROPIC_API_KEY }}" ] && [ -z "${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}" ]; then
            echo "::error::Missing required API keys. Please set either ANTHROPIC_API_KEY or CLAUDE_CODE_OAUTH_TOKEN in repository secrets."
            echo "::error::Visit: https://github.com/${{ github.repository }}/settings/secrets/actions"
            exit 1
          fi
          echo "‚úÖ API key configuration verified"

      - name: Determine PR and branches
        id: pick
        uses: actions/github-script@v7
        with:
          script: |
            try {
              if (context.eventName === 'workflow_dispatch') {
                const prBranch = '${{ inputs.pr_branch }}';
                const baseBranch = '${{ inputs.base_branch }}' || 'main';
                
                if (!prBranch) {
                  core.setFailed('For manual run, pr_branch input is required.');
                  return;
                }
                
                core.setOutput('head_ref', prBranch);
                core.setOutput('base_ref', baseBranch);
                core.setOutput('number', '');
                core.setOutput('same_repo', 'true');
                core.setOutput('pr_url', '');
                core.info(`Manual run: ${prBranch} -> ${baseBranch}`);
                return;
              }

              // workflow_run path
              const run = context.payload.workflow_run;
              const prLite = run.pull_requests && run.pull_requests[0];
              
              if (!prLite) {
                core.setFailed('No PR associated with this workflow run. This might be a push to main branch.');
                return;
              }

              // Fetch full PR details
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner, 
                repo: context.repo.repo, 
                pull_number: prLite.number
              });
              
              const sameRepo = pr.head.repo.full_name === `${context.repo.owner}/${context.repo.repo}`;
              
              core.setOutput('head_ref', pr.head.ref);
              core.setOutput('base_ref', pr.base.ref);
              core.setOutput('number', pr.number.toString());
              core.setOutput('same_repo', sameRepo ? 'true' : 'false');
              core.setOutput('pr_url', pr.html_url);
              
              core.info(`PR #${pr.number}: ${pr.head.ref} -> ${pr.base.ref} (same_repo: ${sameRepo})`);
              
            } catch (error) {
              core.setFailed(`Failed to determine PR details: ${error.message}`);
            }

      - name: Checkout target branch
        uses: actions/checkout@v5
        with:
          ref: ${{ steps.pick.outputs.head_ref }}
          fetch-depth: 0
          persist-credentials: true
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Setup git identity
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name  "github-actions[bot]"
          git config --global init.defaultBranch main

      - name: Cleanup old fix branches
        if: steps.pick.outputs.same_repo == 'false'
        continue-on-error: true
        run: |
          echo "::group::Cleaning up old fix branches"
          
          # Get all claude-auto-fix branches, sorted by creation date (oldest first)
          OLD_BRANCHES=$(git branch -r --sort=creatordate | grep "origin/claude-auto-fix-ci-" | head -n -${{ env.CLEANUP_THRESHOLD }} || true)
          
          if [ -n "$OLD_BRANCHES" ]; then
            echo "Found old branches to cleanup:"
            echo "$OLD_BRANCHES"
            
            echo "$OLD_BRANCHES" | while read -r branch; do
              # Remove origin/ prefix and delete branch
              BRANCH_NAME=${branch#origin/}
              echo "Deleting branch: $BRANCH_NAME"
              git push origin --delete "$BRANCH_NAME" || echo "Failed to delete $BRANCH_NAME"
            done
          else
            echo "No old branches to cleanup"
          fi
          
          echo "::endgroup::"

      - name: Decide fix branch strategy
        id: branch
        run: |
          if [ "${{ steps.pick.outputs.same_repo }}" = "true" ]; then
            echo "branch=${{ steps.pick.outputs.head_ref }}" >> $GITHUB_OUTPUT
            echo "mode=direct" >> $GITHUB_OUTPUT
            echo "üîß Will push fixes directly to: ${{ steps.pick.outputs.head_ref }}"
          else
            # Create unique branch name with timestamp to avoid collisions
            TIMESTAMP=$(date +%s)
            FIX_BRANCH="claude-auto-fix-ci-${{ steps.pick.outputs.head_ref }}-${{ github.run_id }}-${TIMESTAMP}"
            
            echo "Creating fix branch: $FIX_BRANCH"
            git checkout -b "$FIX_BRANCH"
            
            echo "branch=$FIX_BRANCH" >> $GITHUB_OUTPUT
            echo "mode=branch" >> $GITHUB_OUTPUT
            echo "üîß Created fix branch: $FIX_BRANCH"
          fi

      - name: Collect failed job details
        if: github.event_name == 'workflow_run'
        id: details
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const run_id = context.payload.workflow_run.id;
              
              // Get all jobs for the failed workflow run
              const { data } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner, 
                repo: context.repo.repo, 
                run_id
              });
              
              const failed = data.jobs.filter(j => j.conclusion === 'failure');
              const failedNames = failed.map(j => j.name);
              const failedDetails = failed.map(j => ({
                name: j.name,
                steps: j.steps?.filter(s => s.conclusion === 'failure').map(s => ({
                  name: s.name,
                  conclusion: s.conclusion
                })) || []
              }));
              
              core.setOutput('failed', JSON.stringify(failedNames));
              core.setOutput('failed_details', JSON.stringify(failedDetails));
              
              core.info(`Found ${failedNames.length} failed jobs: ${failedNames.join(', ')}`);
              
            } catch (error) {
              core.setFailed(`Failed to collect job details: ${error.message}`);
            }

      - name: Pre-Claude analysis
        run: |
          echo "::group::Pre-Claude Analysis"
          echo "Current working directory: $(pwd)"
          echo "Files in repository:"
          find . -name "*.py" -type f | head -10
          
          echo ""
          echo "Checking Python file syntax before Claude:"
          for pyfile in python/*.py; do
            if [ -f "$pyfile" ]; then
              echo "Checking $pyfile..."
              python3 -m py_compile "$pyfile" 2>&1 || echo "‚ùå Syntax error in $pyfile"
            fi
          done
          
          echo ""
          echo "Git status before Claude:"
          git status --porcelain
          echo "::endgroup::"

      - name: Create backup before Claude changes
        run: |
          echo "::group::Creating backup"
          git stash push -m "backup-before-claude-$(date +%s)" --include-untracked || echo "Nothing to backup"
          echo "::endgroup::"

      - name: Claude - Attempt targeted CI fixes
        id: claude
        continue-on-error: true
        uses: anthropics/claude-code-action@v1
        with:
          prompt: |
            ## üö® CRITICAL CI FAILURE - IMMEDIATE FIXES REQUIRED
            
            **Repository:** ${{ github.repository }}
            **Branch:** ${{ steps.pick.outputs.head_ref }} ‚Üí ${{ steps.pick.outputs.base_ref }}
            **Failed Jobs:** ${{ steps.details.outputs.failed || 'Manual run - analyze all files' }}
            
            ## üéØ YOUR MISSION: Fix ALL CI failures
            
            A CI workflow has FAILED and needs immediate fixes. You MUST:
            
            ### 1. **ANALYZE FAILURES**
            - Read ALL Python files in the repository 
            - Check for syntax errors, import errors, and logical issues
            - Look specifically at `python/broken_python.py` and `src/` files
            - Examine any linting/test output for specific error codes
            
            ### 2. **FIX THESE SPECIFIC ISSUES**
            **Python Syntax Errors** (CRITICAL):
            - Missing colons in function definitions
            - Invalid variable assignments 
            - Import errors for non-existent modules
            - Function call syntax errors
            
            **Linting and Type Errors** (CRITICAL):
            - Missing type annotations (ANN001, ANN201, ANN204)
            - Import issues (F401 unused imports, UP035/UP006 deprecated typing)
            - Formatting issues (W292 missing newlines, W293 blank line whitespace)
            - Code style (Q000 quote style, E501 line length, D401 docstring style)
            - Logic simplification (SIM102, SIM201)
            
            **Common CI Issues**:
            - Linting errors (ruff, flake8, black, isort)
            - Test failures and assertion errors
            - Type checking issues
            - Dependency/import problems
            
            ### 3. **IMPLEMENTATION RULES**
            ‚úÖ **DO**: Fix syntax errors, remove bad imports, correct function definitions
            ‚úÖ **DO**: Add missing type annotations to all functions and parameters  
            ‚úÖ **DO**: Fix import statements (remove unused, update deprecated typing)
            ‚úÖ **DO**: Add missing newlines at end of files
            ‚úÖ **DO**: Remove whitespace from blank lines
            ‚úÖ **DO**: Use double quotes consistently (Q000)
            ‚úÖ **DO**: Break long lines under 88 characters (E501)
            ‚úÖ **DO**: Simplify nested if statements (SIM102, SIM201)
            ‚úÖ **DO**: Make sure ALL Python files compile without errors
            ‚úÖ **DO**: Run linting checks: `ruff check . --fix`
            ‚ùå **DON'T**: Modify .github/workflows/ files
            ‚ùå **DON'T**: Change core business logic unnecessarily
            
            ### 4. **VERIFICATION STEPS**
            After making changes, MUST verify:
            ```bash
            # Check Python syntax
            python3 -m py_compile python/*.py src/*.py
            
            # Run linting and auto-fix what you can
            ruff check . --fix
            ruff format .
            
            # Run tests if they exist
            cd python && python -m pytest . || python -m unittest discover || true
            
            # Final verification that files are clean
            ruff check . --no-fix
            ```
            
            ## üöÄ START FIXING NOW!
            
            **CRITICAL**: The CI is failing with specific linting errors. You must fix ALL of these:
            
            **Files to fix:**
            - `python/broken_python.py` - Add type annotations, fix formatting
            - `src/main.py` - Fix imports, type annotations, formatting, logic
            - `src/__init__.py` - Add missing newline
            
            **Specific error codes to address:**
            - **ANN001/ANN201/ANN204**: Add type annotations to ALL functions and parameters
            - **F401**: Remove unused imports like `typing.Any`  
            - **UP035/UP006**: Replace `List` with `list`, remove `typing.List`
            - **W292/W293**: Add newlines, remove whitespace from blank lines
            - **Q000**: Use double quotes consistently
            - **E501**: Break lines over 88 characters
            - **SIM102/SIM201**: Simplify nested conditions
            - **D401**: Fix docstring imperative mood
            - **TRY401**: Remove redundant exception args in logging
            
            **Success criteria:** ALL ruff/linting errors resolved, files pass `ruff check .`
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY || secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          acknowledge-dangerously-skip-permissions-responsibility: "true"
          claude_args: "--max-turns 15 --model claude-sonnet-4-20250514 --dangerously-skip-permissions"

      - name: Verify Claude changes and run tests
        if: steps.claude.outcome == 'success'
        run: |
          echo "::group::Verifying changes made by Claude"
          
          # Check if any files were modified
          CHANGED_FILES=$(git diff --name-only HEAD || true)
          STAGED_FILES=$(git diff --staged --name-only || true)
          UNTRACKED_FILES=$(git ls-files --others --exclude-standard || true)
          
          echo "Modified files:"
          echo "${CHANGED_FILES:-None}"
          echo ""
          echo "Staged files:"
          echo "${STAGED_FILES:-None}"
          echo ""
          echo "Untracked files:"
          echo "${UNTRACKED_FILES:-None}"
          
          # Show a summary of changes
          if [ -n "$CHANGED_FILES" ] || [ -n "$STAGED_FILES" ] || [ -n "$UNTRACKED_FILES" ]; then
            echo ""
            echo "Summary of changes:"
            git status --porcelain=v1
            echo ""
            echo "Detailed diff:"
            git diff HEAD
            
            echo ""
            echo "::group::Testing fixes"
            
            # Test Python syntax
            if ls python/*.py >/dev/null 2>&1; then
              echo "Testing Python syntax..."
              for pyfile in python/*.py; do
                if python3 -m py_compile "$pyfile" 2>&1; then
                  echo "‚úÖ $pyfile: Syntax OK"
                else
                  echo "‚ùå $pyfile: Syntax Error"
                fi
              done
            fi
            
            # Run basic syntax validation
            echo "Running final syntax check..."
            for pyfile in python/*.py; do
              if [ -f "$pyfile" ]; then
                python3 -c "import ast; ast.parse(open('$pyfile').read())" && echo "‚úÖ $pyfile: Syntax valid" || echo "‚ùå $pyfile: Syntax error"
              fi
            done
            
            echo "::endgroup::"
          else
            echo "No changes detected - Claude may not have found fixable issues"
          fi
          
          echo "::endgroup::"

      - name: Debug Claude execution
        if: always()
        run: |
          echo "::group::Claude Execution Debug"
          echo "Claude outcome: ${{ steps.claude.outcome }}"
          echo "Claude conclusion: ${{ steps.claude.conclusion }}"
          
          # Check Claude Code action logs/outputs
          echo ""
          echo "Current git status:"
          git status --porcelain
          
          echo ""
          echo "Any new or modified files?"
          git diff --name-only HEAD 2>/dev/null || echo "No diff available"
          
          echo ""
          echo "Staged files:"
          git diff --staged --name-only 2>/dev/null || echo "No staged files"
          
          # Check if we have any Python files with remaining issues
          echo ""
          echo "Post-Claude Python syntax check:"
          for pyfile in python/*.py; do
            if [ -f "$pyfile" ]; then
              if python3 -m py_compile "$pyfile" 2>&1; then
                echo "‚úÖ $pyfile: OK"
              else
                echo "‚ùå $pyfile: Still has errors"
                echo "Content preview:"
                head -30 "$pyfile" | nl
              fi
            fi
          done
          echo "::endgroup::"

      - name: Handle Claude failure
        if: steps.claude.outcome == 'failure'
        run: |
          echo "::warning::Claude failed to make fixes. This could be due to:"
          echo "- Complex issues requiring human intervention"
          echo "- API rate limits or connectivity issues"  
          echo "- Repository structure that Claude couldn't understand"
          echo "- Permission issues with file modifications"
          echo ""
          echo "Manual investigation may be required."
          
          # Show what Claude was supposed to fix
          echo ""
          echo "Expected fixes needed:"
          echo "- python/broken_python.py: Multiple syntax errors"
          
          # Restore backup if it exists
          git stash pop || echo "No backup to restore"

      - name: Commit and push changes
        if: steps.claude.outcome == 'success'
        run: |
          echo "::group::Committing changes"
          
          # Stage all changes
          git add -A
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "::notice::No changes to commit - Claude may have determined no fixes were needed"
            exit 0
          fi
          
          # Create detailed commit message
          COMMIT_MSG="chore(ci): auto-fix CI failures

          Auto-generated fixes for failing CI jobs:
          ${{ steps.details.outputs.failed || 'Manual run' }}
          
          Generated by: ${{ github.workflow }} #${{ github.run_number }}
          Triggered by: ${{ github.event_name }}
          Repository: ${{ github.repository }}"
          
          git commit -m "$COMMIT_MSG"
          
          # Configure git with PAT if available to trigger workflows
          if [ -n "${{ secrets.PAT_TOKEN }}" ]; then
            git config --global url."https://x-access-token:${{ secrets.PAT_TOKEN }}@github.com/".insteadOf "https://github.com/"
            echo "‚úÖ Configured git with PAT to trigger workflows"
          else
            echo "‚ö†Ô∏è  Using GITHUB_TOKEN - new workflows may not trigger"
          fi
          
          # Push with retry logic
          for i in $(seq 1 ${{ env.MAX_RETRY_ATTEMPTS }}); do
            if git push -u origin "${{ steps.branch.outputs.branch }}"; then
              echo "‚úÖ Successfully pushed changes (attempt $i)"
              break
            else
              echo "‚ö†Ô∏è  Push failed (attempt $i/${{ env.MAX_RETRY_ATTEMPTS }})"
              if [ $i -lt ${{ env.MAX_RETRY_ATTEMPTS }} ]; then
                echo "Retrying in 5 seconds..."
                sleep 5
                git pull --rebase origin "${{ steps.branch.outputs.branch }}" || true
              else
                echo "::error::Failed to push after ${{ env.MAX_RETRY_ATTEMPTS }} attempts"
                exit 1
              fi
            fi
          done
          
          echo "::endgroup::"

      - name: Trigger CI re-run (if PAT available)
        if: steps.claude.outcome == 'success'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const hasPAT = '${{ secrets.PAT_TOKEN }}' !== '';
            
            if (!hasPAT) {
              console.log('‚ö†Ô∏è PAT_TOKEN not configured - using GITHUB_TOKEN');
              console.log('New workflows may not trigger automatically due to GitHub security restrictions');
              return;
            }
            
            // Try to re-run the original failed workflow
            const workflowId = "${{ github.event.workflow_run.workflow_id || 'ci.yml' }}";
            const ref = "${{ steps.pick.outputs.head_ref }}";
            
            try {
              // Dispatch the CI workflow on the target branch
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowId,
                ref: ref
              });
              
              console.log(`‚úÖ Triggered workflow ${workflowId} on branch ${ref}`);
              
            } catch (error) {
              console.log(`‚ö†Ô∏è Could not trigger workflow: ${error.message}`);
              console.log('Workflows will trigger automatically on push if PAT has correct permissions');
            }

      - name: Comment on original PR (direct push)
        if: |
          github.event_name == 'workflow_run' && 
          steps.branch.outputs.mode == 'direct' && 
          steps.pick.outputs.number != '' &&
          steps.claude.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const commentBody = `ü§ñ **Auto-fixes applied**
            
            I've automatically pushed fixes for the failing CI jobs directly to \`${{ steps.pick.outputs.head_ref }}\`.
            
            **Fixed jobs:** ${{ steps.details.outputs.failed }}
            
            **Changes made:**
            - Fixed Python syntax errors (missing colons, invalid assignments)
            - Corrected import statements and function definitions
            - Applied minimal fixes to resolve CI failures
            
            The CI will re-run automatically. If workflows don't trigger, configure a PAT_TOKEN secret with workflow permissions. If issues persist, manual intervention may be required.
            
            <details>
            <summary>Workflow Details</summary>
            
            - **Workflow:** ${{ github.workflow }}
            - **Run:** #${{ github.run_number }}
            - **Commit:** \`${context.sha.substring(0, 7)}\`
            </details>`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number('${{ steps.pick.outputs.number }}'),
              body: commentBody
            });

      - name: Create PR for fixes (fork case)
        if: steps.branch.outputs.mode == 'branch' && steps.claude.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const head = "${{ steps.branch.outputs.branch }}";
            const base = "${{ steps.pick.outputs.base_ref }}";
            
            // Check if PR already exists
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner, 
              repo: context.repo.repo, 
              state: 'open',
              head: `${context.repo.owner}:${head}`
            });
            
            if (prs.length > 0) {
              core.info(`PR already exists: ${prs[0].html_url}`);
              return;
            }
            
            // Create new PR
            const prBody = `ü§ñ **Automated CI Fixes**
            
            This PR contains automated fixes for failing CI jobs in the original PR.
            
            **Target PR:** ${{ steps.pick.outputs.pr_url }}
            **Failed Jobs:** ${{ steps.details.outputs.failed }}
            
            ## Changes made
            - Fixed Python syntax errors (missing colons, invalid assignments)
            - Corrected import statements and function definitions  
            - Applied minimal fixes to resolve CI failures
            - All changes are targeted at making tests pass
            
            ## Next Steps
            1. Review the changes in this PR
            2. If approved, merge this PR
            3. The fixes will be available for the original PR
            
            ---
            *Generated by ${{ github.workflow }} #${{ github.run_number }}*`;
            
            try {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner, 
                repo: context.repo.repo,
                title: `chore(ci): auto-fix CI failures for ${{ steps.pick.outputs.head_ref }}`,
                head: head,
                base: base,
                body: prBody
              });
              
              core.info(`‚úÖ Created fix PR: ${pr.html_url}`);
              
              // Add labels if they exist
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: ['automated', 'ci-fix', 'claude-generated']
                });
              } catch (labelError) {
                core.info('Could not add labels (labels may not exist)');
              }
              
            } catch (error) {
              core.setFailed(`Failed to create PR: ${error.message}`);
            }

      - name: Summary
        if: always()
        run: |
          echo "::group::Workflow Summary"
          echo "Event: ${{ github.event_name }}"
          echo "Branch Strategy: ${{ steps.branch.outputs.mode }}"
          echo "Target Branch: ${{ steps.branch.outputs.branch }}"
          echo "Claude Status: ${{ steps.claude.outcome }}"
          echo "PR Number: ${{ steps.pick.outputs.number }}"
          echo "::endgroup::"
          
          if [ "${{ steps.claude.outcome }}" = "success" ]; then
            echo "‚úÖ Workflow completed successfully"
          elif [ "${{ steps.claude.outcome }}" = "failure" ]; then
            echo "‚ö†Ô∏è  Claude fixes failed - manual intervention may be required"
          else
            echo "‚ÑπÔ∏è  Workflow completed with mixed results"
          fi