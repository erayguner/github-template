name: Auto Fix CI Failures

on:
  workflow_run:
    workflows: ["Basic CI"]        # TODO: Update this to match your CI workflow name exactly
    types: [completed]
  workflow_dispatch:
    inputs:
      pr_branch:
        description: "PR head branch (for manual testing; same-repo only)"
        required: false
      base_branch:
        description: "Base branch (default: main)"
        required: false
        default: "main"
      force_run:
        description: "Force run even if no failures detected"
        type: boolean
        required: false
        default: false

permissions:
  contents: write
  pull-requests: write
  actions: read
  id-token: write

env:
  MAX_RETRY_ATTEMPTS: 3
  CLEANUP_THRESHOLD: 10  # Keep only last 10 fix branches

jobs:
  auto-fix:
    # Only for failed runs OR manual runs
    if: |
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'failure' &&
       !startsWith(github.event.workflow_run.head_branch, 'claude-auto-fix-ci-')) ||
      (github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Print triggering context (debug)
        run: |
          echo "::group::Trigger Context"
          echo "event_name=${{ github.event_name }}"
          echo "repository=${{ github.repository }}"
          echo "run_id=${{ github.run_id }}"
          echo "run_number=${{ github.run_number }}"

          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "workflow_run.name=${{ github.event.workflow_run.name }}"
            echo "workflow_run.conclusion=${{ github.event.workflow_run.conclusion }}"
            echo "workflow_run.event=${{ github.event.workflow_run.event }}"
            echo "workflow_run.head_branch=${{ github.event.workflow_run.head_branch }}"
            echo "workflow_run.id=${{ github.event.workflow_run.id }}"
          else
            echo "manual pr_branch=${{ inputs.pr_branch }}"
            echo "manual base_branch=${{ inputs.base_branch }}"
            echo "manual force_run=${{ inputs.force_run }}"
          fi
          echo "::endgroup::"

      - name: Verify Claude API key exists
        run: |
          if [ -z "${{ secrets.ANTHROPIC_API_KEY }}" ] && [ -z "${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}" ]; then
            echo "::error::Missing required API keys. Please set either ANTHROPIC_API_KEY or CLAUDE_CODE_OAUTH_TOKEN in repository secrets."
            echo "::error::Visit: https://github.com/${{ github.repository }}/settings/secrets/actions"
            exit 1
          fi
          echo "‚úÖ API key configuration verified"

      - name: Determine PR and branches
        id: pick
        uses: actions/github-script@v7
        with:
          script: |
            try {
              if (context.eventName === 'workflow_dispatch') {
                const prBranch = '${{ inputs.pr_branch }}';
                const baseBranch = '${{ inputs.base_branch }}' || 'main';

                if (!prBranch) {
                  core.setFailed('For manual run, pr_branch input is required.');
                  return;
                }

                core.setOutput('head_ref', prBranch);
                core.setOutput('base_ref', baseBranch);
                core.setOutput('number', '');
                core.setOutput('same_repo', 'true');
                core.setOutput('pr_url', '');
                core.info(`Manual run: ${prBranch} -> ${baseBranch}`);
                return;
              }

              // workflow_run path
              const run = context.payload.workflow_run;
              const prLite = run.pull_requests && run.pull_requests[0];

              if (!prLite) {
                core.setFailed('No PR associated with this workflow run. This might be a push to main branch.');
                return;
              }

              // Fetch full PR details
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prLite.number
              });

              const sameRepo = pr.head.repo.full_name === `${context.repo.owner}/${context.repo.repo}`;

              core.setOutput('head_ref', pr.head.ref);
              core.setOutput('base_ref', pr.base.ref);
              core.setOutput('number', pr.number.toString());
              core.setOutput('same_repo', sameRepo ? 'true' : 'false');
              core.setOutput('pr_url', pr.html_url);

              core.info(`PR #${pr.number}: ${pr.head.ref} -> ${pr.base.ref} (same_repo: ${sameRepo})`);

            } catch (error) {
              core.setFailed(`Failed to determine PR details: ${error.message}`);
            }

      - name: Checkout target branch
        uses: actions/checkout@v6
        with:
          ref: ${{ steps.pick.outputs.head_ref }}
          fetch-depth: 0
          persist-credentials: true
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Setup git identity
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name  "github-actions[bot]"
          git config --global init.defaultBranch main

      - name: Cleanup old fix branches
        if: steps.pick.outputs.same_repo == 'false'
        continue-on-error: true
        run: |
          echo "::group::Cleaning up old fix branches"

          # Get all claude-auto-fix branches, sorted by creation date (oldest first)
          OLD_BRANCHES=$(git branch -r --sort=creatordate | grep "origin/claude-auto-fix-ci-" | head -n -${{ env.CLEANUP_THRESHOLD }} || true)

          if [ -n "$OLD_BRANCHES" ]; then
            echo "Found old branches to cleanup:"
            echo "$OLD_BRANCHES"

            echo "$OLD_BRANCHES" | while read -r branch; do
              # Remove origin/ prefix and delete branch
              BRANCH_NAME=${branch#origin/}
              echo "Deleting branch: $BRANCH_NAME"
              git push origin --delete "$BRANCH_NAME" || echo "Failed to delete $BRANCH_NAME"
            done
          else
            echo "No old branches to cleanup"
          fi

          echo "::endgroup::"

      - name: Decide fix branch strategy
        id: branch
        run: |
          if [ "${{ steps.pick.outputs.same_repo }}" = "true" ]; then
            echo "branch=${{ steps.pick.outputs.head_ref }}" >> "$GITHUB_OUTPUT"
            echo "mode=direct" >> "$GITHUB_OUTPUT"
            echo "üîß Will push fixes directly to: ${{ steps.pick.outputs.head_ref }}"
          else
            # Create unique branch name with timestamp to avoid collisions
            TIMESTAMP=$(date +%s)
            FIX_BRANCH="claude-auto-fix-ci-${{ steps.pick.outputs.head_ref }}-${{ github.run_id }}-${TIMESTAMP}"

            echo "Creating fix branch: ${FIX_BRANCH}"
            git checkout -b "${FIX_BRANCH}"

            echo "branch=${FIX_BRANCH}" >> "$GITHUB_OUTPUT"
            echo "mode=branch" >> "$GITHUB_OUTPUT"
            echo "üîß Created fix branch: ${FIX_BRANCH}"
          fi

      - name: Collect failed job details
        if: github.event_name == 'workflow_run'
        id: details
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const run_id = context.payload.workflow_run.id;

              // Get all jobs for the failed workflow run
              const { data } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id
              });

              const failed = data.jobs.filter(j => j.conclusion === 'failure');
              const failedNames = failed.map(j => j.name);
              const failedDetails = failed.map(j => ({
                name: j.name,
                steps: j.steps?.filter(s => s.conclusion === 'failure').map(s => ({
                  name: s.name,
                  conclusion: s.conclusion
                })) || []
              }));

              core.setOutput('failed', JSON.stringify(failedNames));
              core.setOutput('failed_details', JSON.stringify(failedDetails));

              core.info(`Found ${failedNames.length} failed jobs: ${failedNames.join(', ')}`);

            } catch (error) {
              core.setFailed(`Failed to collect job details: ${error.message}`);
            }

      - name: Pre-Claude analysis
        run: |
          echo "::group::Pre-Claude Analysis"
          echo "Current working directory: $(pwd)"
          echo "Files in repository:"
          find . -name "*.py" -type f | head -10

          echo ""
          echo "Checking Python file syntax before Claude:"
          for pyfile in python/*.py; do
            if [ -f "$pyfile" ]; then
              echo "Checking $pyfile..."
              python3 -m py_compile "$pyfile" 2>&1 || echo "‚ùå Syntax error in $pyfile"
            fi
          done

          echo ""
          echo "Git status before Claude:"
          git status --porcelain
          echo "::endgroup::"

      - name: Create backup before Claude changes
        run: |
          echo "::group::Creating backup"
          git stash push -m "backup-before-claude-$(date +%s)" --include-untracked || echo "Nothing to backup"
          echo "::endgroup::"

      - name: Claude - Attempt targeted CI fixes
        id: claude
        continue-on-error: true
        uses: anthropics/claude-code-action@v1
        with:
          prompt: |
            ## üö® CRITICAL CI FAILURE - IMMEDIATE FIXES REQUIRED

            **Repository:** ${{ github.repository }}
            **Branch:** ${{ steps.pick.outputs.head_ref }} ‚Üí ${{ steps.pick.outputs.base_ref }}
            **Failed Jobs:** ${{ steps.details.outputs.failed || 'Manual run - analyze all files' }}

            ## üéØ YOUR MISSION: Fix ALL CI failures

            A CI workflow has FAILED and needs immediate fixes. You MUST:

            ### 1. **ANALYZE FAILURES**
            - Read ALL Python files in the repository
            - Check for syntax errors, import errors, and logical issues
            - Look specifically at `python/broken_python.py` and `src/` files
            - Examine any linting/test output for specific error codes

            ### 2. **FIX THESE SPECIFIC ISSUES**
            **Python Syntax Errors** (CRITICAL):
            - Missing colons in function definitions
            - Invalid variable assignments
            - Import errors for non-existent modules
            - Function call syntax errors

            **Linting and Type Errors** (CRITICAL):
            - Missing type annotations (ANN001, ANN201, ANN204)
            - Import issues (F401 unused imports, UP035/UP006 deprecated typing)
            - Formatting issues (W292 missing newlines, W293 blank line whitespace)
            - Code style (Q000 quote style, E501 line length, D401 docstring style)
            - Logic simplification (SIM102, SIM201)

            **Common CI Issues**:
            - Linting errors (ruff, flake8, black, isort)
            - Test failures and assertion errors
            - Type checking issues
            - Dependency/import problems

            ### 3. **IMPLEMENTATION RULES**
            ‚úÖ **DO**: Use automated tools FIRST: `ruff check . --fix` and `black .`
            ‚úÖ **DO**: Fix syntax errors, remove bad imports, correct function definitions
            ‚úÖ **DO**: Add missing type annotations to all functions and parameters
            ‚úÖ **DO**: Fix import statements (remove unused, update deprecated typing)
            ‚úÖ **DO**: Add missing newlines at end of files (W292)
            ‚úÖ **DO**: Remove whitespace from blank lines (W293)
            ‚úÖ **DO**: Use double quotes consistently (Q000)
            ‚úÖ **DO**: Break long lines under 88 characters (E501)
            ‚úÖ **DO**: Simplify logic: `!= "true"` instead of `not == "true"` (SIM201)
            ‚úÖ **DO**: Replace `List` with `list` in type annotations (UP006)
            ‚úÖ **DO**: Remove redundant exception args from logging.exception() (TRY401)
            ‚úÖ **DO**: Make sure ALL Python files compile without errors
            ‚ùå **DON'T**: Modify .github/workflows/ files
            ‚ùå **DON'T**: Change core business logic unnecessarily

            ### 4. **STEP-BY-STEP FIXING PROCESS**
            You MUST follow this exact sequence:
            ```bash
            # Step 1: Run automated formatters and fixers FIRST
            ruff check . --fix --unsafe-fixes
            black . --line-length 88
            ruff format .

            # Step 2: Check Python syntax
            python3 -m py_compile python/*.py src/*.py

            # Step 3: Manual fixes for remaining issues
            # - Add type annotations where missing
            # - Fix specific logic issues (SIM201, TRY401)
            # - Update imports (UP006: List -> list)
            # - Fix docstrings (D401)

            # Step 4: Final verification
            ruff check . --no-fix
            python3 -m py_compile python/*.py src/*.py
            ```

            ## üöÄ START FIXING NOW!

            **CRITICAL**: The CI is failing with specific linting errors. You must fix ALL of these:

            **Files to fix:**
            - `python/broken_python.py` - Add type annotations, fix formatting
            - `src/main.py` - Fix imports, type annotations, formatting, logic
            - `src/__init__.py` - Add missing newline

            **Specific error codes to address (USE AUTOMATED TOOLS FIRST):**

            **AUTOMATED FIXES (ruff + black handle these):**
            - **W292**: No newline at end of file ‚Üí `ruff check . --fix`
            - **W293**: Blank line contains whitespace ‚Üí `ruff check . --fix`
            - **Q000**: Single quotes ‚Üí Use double quotes ‚Üí `ruff check . --fix`
            - **E501**: Line too long ‚Üí `black . --line-length 88`
            - **F401**: Remove unused imports ‚Üí `ruff check . --fix`

            **MANUAL FIXES (after automated tools):**
            - **ANN001/ANN201/ANN204**: Add type annotations to ALL functions and parameters
            - **UP006**: Replace `List` with `list` in type annotations
            - **SIM201**: Change `not x == "true"` to `x != "true"`
            - **TRY401**: Remove redundant exception object from `logging.exception("msg", e)` ‚Üí `logging.exception("msg")`
            - **D401**: Fix docstring imperative mood
            - **SIM102**: Combine nested if statements

            **SUCCESS CRITERIA:**
            1. Run `ruff check . --fix --unsafe-fixes` first
            2. Run `black . --line-length 88` second
            3. Manual fixes for remaining issues
            4. Final check: `ruff check . --no-fix` shows ZERO errors
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY || secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          claude_args: "--max-turns 15 --model claude-sonnet-4-20250514 --dangerously-skip-permissions"

      - name: Verify Claude changes and run tests
        if: steps.claude.outcome == 'success'
        run: |
          echo "::group::Verifying changes made by Claude"

          # Check if any files were modified
          CHANGED_FILES=$(git diff --name-only HEAD || true)
          STAGED_FILES=$(git diff --staged --name-only || true)
          UNTRACKED_FILES=$(git ls-files --others --exclude-standard || true)

          echo "Modified files:"
          echo "${CHANGED_FILES:-None}"
          echo ""
          echo "Staged files:"
          echo "${STAGED_FILES:-None}"
          echo ""
          echo "Untracked files:"
          echo "${UNTRACKED_FILES:-None}"

          # Show a summary of changes
          if [ -n "$CHANGED_FILES" ] || [ -n "$STAGED_FILES" ] || [ -n "$UNTRACKED_FILES" ]; then
            echo ""
            echo "Summary of changes:"
            git status --porcelain=v1
            echo ""
            echo "Detailed diff:"
            git diff HEAD

            echo ""
            echo "::group::Testing fixes"

            # Test Python syntax
            if ls python/*.py >/dev/null 2>&1; then
              echo "Testing Python syntax..."
              for pyfile in python/*.py; do
                if python3 -m py_compile "$pyfile" 2>&1; then
                  echo "‚úÖ $pyfile: Syntax OK"
                else
                  echo "‚ùå $pyfile: Syntax Error"
                fi
              done
            fi

            # Run basic syntax validation
            echo "Running final syntax check..."
            for pyfile in python/*.py; do
              if [ -f "$pyfile" ]; then
                python3 -c "import ast; ast.parse(open('$pyfile').read())" && echo "‚úÖ $pyfile: Syntax valid" || echo "‚ùå $pyfile: Syntax error"
              fi
            done

            echo "::endgroup::"
          else
            echo "No changes detected - Claude may not have found fixable issues"
          fi

          echo "::endgroup::"

      - name: Debug Claude execution
        if: always()
        run: |
          echo "::group::Claude Execution Debug"
          echo "Claude outcome: ${{ steps.claude.outcome }}"
          echo "Claude conclusion: ${{ steps.claude.conclusion }}"

          # Check Claude Code action logs/outputs
          echo ""
          echo "Current git status:"
          git status --porcelain

          echo ""
          echo "Any new or modified files?"
          git diff --name-only HEAD 2>/dev/null || echo "No diff available"

          echo ""
          echo "Staged files:"
          git diff --staged --name-only 2>/dev/null || echo "No staged files"

          # Check if we have any Python files with remaining issues
          echo ""
          echo "Post-Claude Python syntax check:"
          for pyfile in python/*.py; do
            if [ -f "$pyfile" ]; then
              if python3 -m py_compile "$pyfile" 2>&1; then
                echo "‚úÖ $pyfile: OK"
              else
                echo "‚ùå $pyfile: Still has errors"
                echo "Content preview:"
                head -30 "$pyfile" | nl
              fi
            fi
          done
          echo "::endgroup::"

      - name: Handle Claude failure
        if: steps.claude.outcome == 'failure'
        run: |
          echo "::warning::Claude failed to make fixes. This could be due to:"
          echo "- Complex issues requiring human intervention"
          echo "- API rate limits or connectivity issues"
          echo "- Repository structure that Claude couldn't understand"
          echo "- Permission issues with file modifications"
          echo ""
          echo "Manual investigation may be required."

          # Show what Claude was supposed to fix
          echo ""
          echo "Expected fixes needed:"
          echo "- python/broken_python.py: Multiple syntax errors"

          # Restore backup if it exists
          git stash pop || echo "No backup to restore"

      - name: Commit and push changes
        if: steps.claude.outcome == 'success'
        run: |
          echo "::group::Committing changes"

          # Stage all changes
          git add -A

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "::notice::No changes to commit - Claude may have determined no fixes were needed"
            exit 0
          fi

          # Create detailed commit message
          COMMIT_MSG="chore(ci): auto-fix CI failures

          Auto-generated fixes for failing CI jobs:
          ${{ steps.details.outputs.failed || 'Manual run' }}

          Generated by: ${{ github.workflow }} #${{ github.run_number }}
          Triggered by: ${{ github.event_name }}
          Repository: ${{ github.repository }}"

          git commit -m "$COMMIT_MSG"

          # Configure git with PAT if available to trigger workflows
          if [ -n "${{ secrets.PAT_TOKEN }}" ]; then
            git config --global url."https://x-access-token:${{ secrets.PAT_TOKEN }}@github.com/".insteadOf "https://github.com/"
            echo "‚úÖ Configured git with PAT to trigger workflows"
          else
            echo "‚ö†Ô∏è  Using GITHUB_TOKEN - new workflows may not trigger"
          fi

          # Push with retry logic
          MAX_ATTEMPTS="${{ env.MAX_RETRY_ATTEMPTS }}"
          for i in $(seq 1 "${MAX_ATTEMPTS}"); do
            if git push -u origin "${{ steps.branch.outputs.branch }}"; then
              echo "‚úÖ Successfully pushed changes (attempt ${i})"
              break
            else
              echo "‚ö†Ô∏è  Push failed (attempt ${i}/${MAX_ATTEMPTS})"
              if [ "${i}" -lt "${MAX_ATTEMPTS}" ]; then
                echo "Retrying in 5 seconds..."
                sleep 5
                git pull --rebase origin "${{ steps.branch.outputs.branch }}" || true
              else
                echo "::error::Failed to push after ${MAX_ATTEMPTS} attempts"
                exit 1
              fi
            fi
          done

          echo "::endgroup::"

      - name: Trigger CI re-run (if PAT available)
        if: steps.claude.outcome == 'success'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const hasPAT = '${{ secrets.PAT_TOKEN }}' !== '';

            if (!hasPAT) {
              console.log('‚ö†Ô∏è PAT_TOKEN not configured - using GITHUB_TOKEN');
              console.log('New workflows may not trigger automatically due to GitHub security restrictions');
              return;
            }

            // Try to re-run the original failed workflow
            const workflowId = "${{ github.event.workflow_run.workflow_id || 'ci.yml' }}";
            const ref = "${{ steps.pick.outputs.head_ref }}";

            try {
              // Dispatch the CI workflow on the target branch
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowId,
                ref: ref
              });

              console.log(`‚úÖ Triggered workflow ${workflowId} on branch ${ref}`);

            } catch (error) {
              console.log(`‚ö†Ô∏è Could not trigger workflow: ${error.message}`);
              console.log('Workflows will trigger automatically on push if PAT has correct permissions');
            }

      - name: Comment on original PR (direct push)
        if: |
          github.event_name == 'workflow_run' &&
          steps.branch.outputs.mode == 'direct' &&
          steps.pick.outputs.number != '' &&
          steps.claude.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const commentBody = `ü§ñ **Auto-fixes applied**

            I've automatically pushed fixes for the failing CI jobs directly to \`${{ steps.pick.outputs.head_ref }}\`.

            **Fixed jobs:** ${{ steps.details.outputs.failed }}

            **Changes made:**
            - Fixed Python syntax errors (missing colons, invalid assignments)
            - Corrected import statements and function definitions
            - Applied minimal fixes to resolve CI failures

            The CI will re-run automatically. If workflows don't trigger, configure a PAT_TOKEN secret with workflow permissions. If issues persist, manual intervention may be required.

            <details>
            <summary>Workflow Details</summary>

            - **Workflow:** ${{ github.workflow }}
            - **Run:** #${{ github.run_number }}
            - **Commit:** \`${context.sha.substring(0, 7)}\`
            </details>`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number('${{ steps.pick.outputs.number }}'),
              body: commentBody
            });

      - name: Create PR for fixes (fork case)
        if: steps.branch.outputs.mode == 'branch' && steps.claude.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const head = "${{ steps.branch.outputs.branch }}";
            const base = "${{ steps.pick.outputs.base_ref }}";

            // Check if PR already exists
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${head}`
            });

            if (prs.length > 0) {
              core.info(`PR already exists: ${prs[0].html_url}`);
              return;
            }

            // Create new PR
            const prBody = `ü§ñ **Automated CI Fixes**

            This PR contains automated fixes for failing CI jobs in the original PR.

            **Target PR:** ${{ steps.pick.outputs.pr_url }}
            **Failed Jobs:** ${{ steps.details.outputs.failed }}

            ## Changes made
            - Fixed Python syntax errors (missing colons, invalid assignments)
            - Corrected import statements and function definitions
            - Applied minimal fixes to resolve CI failures
            - All changes are targeted at making tests pass

            ## Next Steps
            1. Review the changes in this PR
            2. If approved, merge this PR
            3. The fixes will be available for the original PR

            ---
            *Generated by ${{ github.workflow }} #${{ github.run_number }}*`;

            try {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `chore(ci): auto-fix CI failures for ${{ steps.pick.outputs.head_ref }}`,
                head: head,
                base: base,
                body: prBody
              });

              core.info(`‚úÖ Created fix PR: ${pr.html_url}`);

              // Add labels if they exist
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: ['automated', 'ci-fix', 'claude-generated']
                });
              } catch (labelError) {
                core.info('Could not add labels (labels may not exist)');
              }

            } catch (error) {
              core.setFailed(`Failed to create PR: ${error.message}`);
            }

      - name: Summary
        if: always()
        run: |
          echo "::group::Workflow Summary"
          echo "Event: ${{ github.event_name }}"
          echo "Branch Strategy: ${{ steps.branch.outputs.mode }}"
          echo "Target Branch: ${{ steps.branch.outputs.branch }}"
          echo "Claude Status: ${{ steps.claude.outcome }}"
          echo "PR Number: ${{ steps.pick.outputs.number }}"
          echo "::endgroup::"

          if [ "${{ steps.claude.outcome }}" = "success" ]; then
            echo "‚úÖ Workflow completed successfully"
          elif [ "${{ steps.claude.outcome }}" = "failure" ]; then
            echo "‚ö†Ô∏è  Claude fixes failed - manual intervention may be required"
          else
            echo "‚ÑπÔ∏è  Workflow completed with mixed results"
          fi
